{"ast":null,"code":"const API_BASE_URL = \"http://127.0.0.1:8000\";\nconst API_BASE_URL_without_http = \"127.0.0.1:8000\";\nexport { API_BASE_URL };\nexport const login = async (email, password) => {\n  const res = await fetch(`${API_BASE_URL}/token`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\n    },\n    body: new URLSearchParams({\n      username: email,\n      password: password\n    })\n  });\n  if (!res.ok) {\n    const errorData = await res.json().catch(() => ({}));\n    throw new Error(errorData.detail || \"Invalid email or password\");\n  }\n  return res.json();\n};\n\n// export const registerPatient = async (payload) => {\n//     const res = await fetch(`${API_BASE_URL}/register_patient`, {\n//         method: \"POST\",\n//         headers: { \"Content-Type\": \"application/json\" },\n//         body: JSON.stringify(payload),\n//     });\n//     if (!res.ok) {\n//         const err = await res.json().catch(() => ({}));\n//         throw new Error(err.detail || \"Registration failed\");\n//     }\n//     return res.json();\n// };\nexport const registerPatient = async payload => {\n  const res = await fetch(`${API_BASE_URL}/register_patient`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  if (!res.ok) {\n    const err = await res.json();\n    throw new Error(err.detail || JSON.stringify(err));\n  }\n  return await res.json();\n};\nexport const registerDoctor = async payload => {\n  const res = await fetch(`${API_BASE_URL}/register_doctor`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  if (!res.ok) {\n    const err = await res.json();\n    throw new Error(err.detail || JSON.stringify(err));\n  }\n  return await res.json();\n};\nexport const registerFamily = async payload => {\n  const res = await fetch(`${API_BASE_URL}/register_family`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  if (!res.ok) {\n    const err = await res.json();\n    throw new Error(err.detail || JSON.stringify(err));\n  }\n  return await res.json();\n};\nasync function fetchWithErrorHandling(url, options = {}) {\n  const response = await fetch(url, options);\n  const data = await response.json();\n  if (!response.ok) {\n    throw new Error(data.detail || `HTTP ${response.status}`);\n  }\n  return data;\n}\n\n// // Get available slots for a doctor on a date\n// export async function getAvailableSlots(doctorId, appDate) {\n//   const url = `${API_BASE_URL}/available_appointment?doctor_id=${doctorId}&app_date=${appDate}`;\n//   return await fetchWithErrorHandling(url);\n// }\n\n// // Reserve a slot\n// export async function reserveSlot(userId, doctorId, appointmentDateTime) {\n//   const appointment = {\n//     doctor_id: doctorId,\n//     appointment_date: appointmentDateTime,\n//   };\n//   const url = `${API_BASE_URL}/reserve_slot?user_id=${userId}`;\n//   return await fetchWithErrorHandling(url, {\n//     method: \"POST\",\n//     headers: { \"Content-Type\": \"application/json\" },\n//     body: JSON.stringify(appointment),\n//   });\n// }\n\n// // Confirm a slot\n// export async function confirmSlot(userId, doctorId, appointmentDateTime) {\n//   const appointment = {\n//     doctor_id: doctorId,\n//     appointment_date: appointmentDateTime,\n//   };\n//   const url = `${API_BASE_URL}/confirm_slot?user_id=${userId}`;\n//   return await fetchWithErrorHandling(url, {\n//     method: \"POST\",\n//     headers: { \"Content-Type\": \"application/json\" },\n//     body: JSON.stringify(appointment),\n//   });\n// }\n\n// // Cancel a reservation\n// export async function cancelSlot(userId, doctorId, appointmentDateTime) {\n//   const url = `${API_BASE_URL}/cancel_slot?doctor_id=${doctorId}&slot_time=${encodeURIComponent(appointmentDateTime)}&user_id=${userId}`;\n//   return await fetchWithErrorHandling(url, { method: \"POST\" });\n// }\n\n// api.js (TEMPORARY MOCK IMPLEMENTATIONS)\n\n// MOCK: Get available slots for a doctor on a date\nexport async function getAvailableSlots(doctorId, appDate) {\n  console.warn(\"MOCK API: getAvailableSlots called. Returning dummy slots to bypass backend crash.\");\n\n  // Simulate a successful API call returning valid time slots (HH:MM:SS format)\n  return [\"09:00:00\", \"09:30:00\", \"10:00:00\", \"10:30:00\", \"14:00:00\", \"14:30:00\"];\n}\n\n// MOCK: Reserve a slot (Bypasses Redis lock logic)\nexport async function reserveSlot(userId, doctorId, appointmentDateTime) {\n  console.warn(\"MOCK API: reserveSlot called. Slot reserved for 300 seconds.\");\n\n  // The frontend expects \"expires_in\" to calculate remaining hold time\n  return {\n    \"message\": \"Slot reserved\",\n    \"expires_in\": 300\n  };\n}\n\n// MOCK: Confirm a slot (Bypasses permanent booking logic)\nexport async function confirmSlot(userId, doctorId, appointmentDateTime) {\n  console.warn(\"MOCK API: confirmSlot called. Booking confirmed.\");\n  return {\n    \"message\": \"Booking confirmed\"\n  };\n}\n\n// MOCK: Cancel a reservation (Bypasses Redis key deletion)\nexport async function cancelSlot(userId, doctorId, appointmentDateTime) {\n  console.warn(\"MOCK API: cancelSlot called. Reservation cancelled.\");\n  return {\n    \"message\": \"Reservation cancelled and slot freed\"\n  };\n}\n\n// Note: Ensure your original `fetchWithErrorHandling` and `API_BASE_URL` are still defined in api.js, \n// as other functions (like login/vitals) may still need them.\n\nexport async function getUser(token) {\n  const res = await fetch(`${API_BASE_URL}/user/me`, {\n    headers: {\n      Authorization: `Bearer ${token}`\n    }\n  });\n  if (!res.ok) throw new Error(\"Unauthorized\");\n  return await res.json();\n}\nexport async function getVitals(token) {\n  const res = await fetch(`${API_BASE_URL}/get_vital`, {\n    headers: {\n      Authorization: `Bearer ${token}`\n    }\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch vitals\");\n  return await res.json();\n}\nexport async function createChatRoom(token, name, participant_ids) {\n  const res = await fetch(`${API_BASE_URL}/chats/create`, {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${token}`,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      name,\n      participant_ids\n    })\n  });\n  if (!res.ok) throw new Error(\"Failed to create chat room\");\n  return res.json();\n}\nexport async function getMyChats(token) {\n  const res = await fetch(`${API_BASE_URL}/chats/my`, {\n    headers: {\n      Authorization: `Bearer ${token}`\n    }\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch chats\");\n  return res.json();\n}\nexport async function addVitals(token, patient_email, bp) {\n  const res = await fetch(`${API_BASE_URL}/add_vital`, {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${token}`,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      patient_email,\n      bp\n    })\n  });\n  if (!res.ok) throw new Error(\"Failed to add vitals\");\n  return res.json();\n}\nexport async function getFamilyMembers(token) {\n  const res = await fetch(`${API_BASE_URL}/family/get_all_family_members`, {\n    headers: {\n      Authorization: `Bearer ${token}`\n    }\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch family members\");\n  return res.json();\n}\n\n// export async function sendInvitation(token, email, relationship_type) {\n//   const res = await fetch(`${API_BASE_URL}/family/send_invitation`, {\n//     method: \"POST\",\n//     headers: {\n//       Authorization: `Bearer ${token}`,\n//       \"Content-Type\": \"application/json\",\n//     },\n//     body: JSON.stringify({ email, relationship_type }),\n//   });\n//   if (!res.ok) throw new Error(\"Failed to send invitation\");\n//   return res.json();\n// }\n\nexport async function getChatMessages(chatId, token) {\n  const res = await fetch(`${API_BASE_URL}/chats/${chatId}/messages`, {\n    headers: {\n      Authorization: \"Bearer \" + token\n    }\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch chat messages\");\n  return res.json();\n}\nexport async function getWsToken(token) {\n  const res = await fetch(`${API_BASE_URL}/ws-token`, {\n    method: \"POST\",\n    headers: {\n      Authorization: \"Bearer \" + token\n    }\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch websocket token\");\n  return res.json();\n}\nexport async function getChatRooms(token) {\n  const res = await fetch(`${API_BASE_URL}/chats/my`, {\n    headers: {\n      Authorization: `Bearer ${token}`\n    }\n  });\n  if (!res.ok) throw new Error(\"Failed to get chat rooms\");\n  return await res.json();\n}\nexport async function getCurrentUser(token) {\n  const res = await fetch(`${API_BASE_URL}/user/me`, {\n    headers: {\n      Authorization: `Bearer ${token}`\n    }\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch user info\");\n  return res.json();\n}\n\n// Logout (just clearing local/session storage)\nexport function logoutUser() {\n  sessionStorage.clear();\n  localStorage.clear();\n}\nexport async function getPendingInvites(token) {\n  const res = await fetch(`${API_BASE_URL}/family/family_invitation_for_current_user`, {\n    headers: {\n      \"Authorization\": `Bearer ${token}`\n    }\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch invitations\");\n  return res.json();\n}\nexport async function respondInvite(token, inviteToken, action) {\n  const res = await fetch(`${API_BASE_URL}/family/respond_invitation`, {\n    method: \"PUT\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${token}`\n    },\n    body: JSON.stringify({\n      token: inviteToken,\n      action: action\n    })\n  });\n  if (!res.ok) throw new Error(\"Failed to respond to invitation\");\n  return res.json();\n}\nconst handleResponse = async res => {\n  if (!res.ok) {\n    const errorBody = await res.json().catch(() => ({\n      detail: res.statusText\n    }));\n    const errorMessage = errorBody.detail ? Array.isArray(errorBody.detail) ? errorBody.detail[0].msg : errorBody.detail : `HTTP error ${res.status}`;\n    throw new Error(errorMessage);\n  }\n  return res.json();\n};\nexport const getUserMe = async token => {\n  const res = await fetch(`${API_BASE_URL}/user/me`, {\n    headers: {\n      \"Authorization\": \"Bearer \" + token\n    }\n  });\n  return handleResponse(res);\n};\nexport const viewMyChats = async () => {\n  const token = sessionStorage.getItem(\"token\");\n  const res = await fetch(`${API_BASE_URL}/chats/my`, {\n    headers: {\n      \"Authorization\": \"Bearer \" + token\n    }\n  });\n  return handleResponse(res);\n};\nexport const addPatientVitals = async (patient_email, bp) => {\n  const token = sessionStorage.getItem(\"token\");\n  const res = await fetch(`${API_BASE_URL}/add_vital`, {\n    method: \"POST\",\n    headers: {\n      \"Authorization\": \"Bearer \" + token,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      patient_email,\n      bp\n    })\n  });\n  return handleResponse(res);\n};\n\n// export const getAllAppointments = async () => {\n//     const token = sessionStorage.getItem(\"token\");\n//     const res = await fetch(`${API_BASE_URL}/get_all_appointments`, {\n//         headers: { \"Authorization\": \"Bearer \" + token }\n//     });\n//     return handleResponse(res);\n// };\n\nexport const respondToAppointment = async (appointment_id, action) => {\n  const token = sessionStorage.getItem(\"token\");\n  const res = await fetch(`${API_BASE_URL}/appointment_response`, {\n    method: \"PUT\",\n    headers: {\n      \"Authorization\": \"Bearer \" + token,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      appointment_id,\n      action\n    })\n  });\n  return handleResponse(res);\n};\n\n// api.js (required addition)\n\nexport const sendFamilyInvite = async (token, invitee_email, relationship_type) => {\n  // Assuming the backend endpoint is '/family/send_invite' or similar\n  const res = await fetch(`${API_BASE_URL}/family/send_invitation`, {\n    method: \"POST\",\n    headers: {\n      \"Authorization\": \"Bearer \" + token,\n      \"Content-Type\": \"application/json\"\n    },\n    // The payload must match the InvitationRequest schema (invitee_email, relationship_type)\n    body: JSON.stringify({\n      invitee_email: invitee_email,\n      relationship_type: relationship_type\n    })\n  });\n  return handleResponse(res);\n  // Assuming handleResponse is a helper that throws an error on !res.ok\n};\nexport function setupWebSocket(doctorId, handleMessage, setWsStatus) {\n  // Use 'ws:' instead of 'wss:' because API_BASE_URL is 'http:'\n  const protocol = 'ws:';\n  const wsUrl = `${protocol}//${API_BASE_URL_without_http}/ws/doctor/${doctorId}/slots`;\n  const wsConnection = new WebSocket(wsUrl);\n  wsConnection.onopen = () => {\n    setWsStatus('Connected');\n    console.log('WebSocket connected');\n  };\n  wsConnection.onclose = () => {\n    setWsStatus('Disconnected');\n    console.log('WebSocket disconnected');\n  };\n  wsConnection.onerror = error => {\n    setWsStatus('Error');\n    console.error('WebSocket error:', error);\n  };\n  wsConnection.onmessage = event => {\n    try {\n      const data = JSON.parse(event.data);\n      // Data check removed: let the component handle doctor_id filtering\n      handleMessage(data);\n    } catch (error) {\n      console.error('Error processing WebSocket message:', error);\n    }\n  };\n  return wsConnection;\n}\n\n// export const removeFamilyMember = async (token, memberId) => {\n//   const response = await fetch(`${API_BASE_URL}/family/remove_family_member/${memberId}`, {\n//     method: 'DELETE',\n//     headers: {\n//       'Authorization': `Bearer ${token}`,\n//       'Content-Type': 'application/json'\n//     }\n//   });\n\n//   if (!response.ok) {\n//     throw new Error('Failed to remove family member');\n//   }\n\n//   return response.json();\n// };\n// api.js (TEMPORARY MOCK)\n\n// Assuming your remove function looks like this:\nexport async function removeFamilyMember(token, memberId) {\n  console.warn(\"MOCK API: removeFamilyMember called. Simulating successful removal.\");\n\n  // Simulate the successful response the frontend expects for deletion.\n  return {\n    \"message\": `Family member ${memberId} successfully removed.`\n  };\n\n  // Original code (UNMOCK THIS WHEN BACKEND IS FIXED):\n  /*\n  const res = await fetch(`${API_BASE_URL}/family/remove_family_member/${memberId}`, {\n      method: \"DELETE\",\n      headers: { \"Authorization\": \"Bearer \" + token },\n  });\n  return handleResponse(res);\n  */\n}\n\n// api.js\n\nexport async function getPatientAppointments(token) {\n  const res = await fetch(`${API_BASE_URL}/patient/appointments`, {\n    headers: {\n      \"Authorization\": `Bearer ${token}`\n    }\n  });\n  return handleResponse(res); // Assuming handleResponse handles 401/403 errors\n}\n\n// Update the getAllAppointments function to explicitly take the token if it needs it \n// (though it likely gets the token from sessionStorage in your existing implementation).\n// Ensure it passes the token in the headers if it relies on auth:\n// Ensure this is the only definition of getAllAppointments in your file:\n\nexport const getAllAppointments = async token => {\n  // Adding token as explicit parameter\n  const tokenToUse = token || sessionStorage.getItem(\"token\"); // Fallback\n\n  // Check if token exists before making the call\n  if (!tokenToUse) {\n    throw new Error(\"Authorization token is missing.\");\n  }\n  const res = await fetch(`${API_BASE_URL}/get_all_appointments`, {\n    headers: {\n      \"Authorization\": \"Bearer \" + tokenToUse\n    }\n  });\n  return handleResponse(res);\n};","map":{"version":3,"names":["API_BASE_URL","API_BASE_URL_without_http","login","email","password","res","fetch","method","headers","body","URLSearchParams","username","ok","errorData","json","catch","Error","detail","registerPatient","payload","JSON","stringify","err","registerDoctor","registerFamily","fetchWithErrorHandling","url","options","response","data","status","getAvailableSlots","doctorId","appDate","console","warn","reserveSlot","userId","appointmentDateTime","confirmSlot","cancelSlot","getUser","token","Authorization","getVitals","createChatRoom","name","participant_ids","getMyChats","addVitals","patient_email","bp","getFamilyMembers","getChatMessages","chatId","getWsToken","getChatRooms","getCurrentUser","logoutUser","sessionStorage","clear","localStorage","getPendingInvites","respondInvite","inviteToken","action","handleResponse","errorBody","statusText","errorMessage","Array","isArray","msg","getUserMe","viewMyChats","getItem","addPatientVitals","respondToAppointment","appointment_id","sendFamilyInvite","invitee_email","relationship_type","setupWebSocket","handleMessage","setWsStatus","protocol","wsUrl","wsConnection","WebSocket","onopen","log","onclose","onerror","error","onmessage","event","parse","removeFamilyMember","memberId","getPatientAppointments","getAllAppointments","tokenToUse"],"sources":["/Users/shreyasingh/Downloads/frontend_changes_telehealth/frontend/src/services/api.js"],"sourcesContent":["const API_BASE_URL = \"http://127.0.0.1:8000\";\nconst API_BASE_URL_without_http = \"127.0.0.1:8000\"; \nexport { API_BASE_URL };\n    \nexport const login = async (email, password) => {\n    const res = await fetch(`${API_BASE_URL}/token`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n        body: new URLSearchParams({ username: email, password: password }), \n    });\n    if (!res.ok) {\n        const errorData = await res.json().catch(() => ({}));\n        throw new Error(errorData.detail || \"Invalid email or password\");\n    }\n    return res.json();\n};\n\n// export const registerPatient = async (payload) => {\n//     const res = await fetch(`${API_BASE_URL}/register_patient`, {\n//         method: \"POST\",\n//         headers: { \"Content-Type\": \"application/json\" },\n//         body: JSON.stringify(payload),\n//     });\n//     if (!res.ok) {\n//         const err = await res.json().catch(() => ({}));\n//         throw new Error(err.detail || \"Registration failed\");\n//     }\n//     return res.json();\n// };\nexport const registerPatient = async (payload) => {\n  const res = await fetch(`${API_BASE_URL}/register_patient`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(payload)\n  });\n  if (!res.ok) {\n    const err = await res.json();\n    throw new Error(err.detail || JSON.stringify(err));\n  }\n  return await res.json();\n};\n\nexport const registerDoctor = async (payload) => {\n  const res = await fetch(`${API_BASE_URL}/register_doctor`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(payload)\n  });\n  if (!res.ok) {\n    const err = await res.json();\n    throw new Error(err.detail || JSON.stringify(err));\n  }\n  return await res.json();\n};\n\nexport const registerFamily = async (payload) => {\n  const res = await fetch(`${API_BASE_URL}/register_family`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(payload)\n  });\n  if (!res.ok) {\n    const err = await res.json();\n    throw new Error(err.detail || JSON.stringify(err));\n  }\n  return await res.json();\n};\n\n\nasync function fetchWithErrorHandling(url, options = {}) {\n  const response = await fetch(url, options);\n  const data = await response.json();\n  if (!response.ok) {\n    throw new Error(data.detail || `HTTP ${response.status}`);\n  }\n  return data;\n}\n\n// // Get available slots for a doctor on a date\n// export async function getAvailableSlots(doctorId, appDate) {\n//   const url = `${API_BASE_URL}/available_appointment?doctor_id=${doctorId}&app_date=${appDate}`;\n//   return await fetchWithErrorHandling(url);\n// }\n\n// // Reserve a slot\n// export async function reserveSlot(userId, doctorId, appointmentDateTime) {\n//   const appointment = {\n//     doctor_id: doctorId,\n//     appointment_date: appointmentDateTime,\n//   };\n//   const url = `${API_BASE_URL}/reserve_slot?user_id=${userId}`;\n//   return await fetchWithErrorHandling(url, {\n//     method: \"POST\",\n//     headers: { \"Content-Type\": \"application/json\" },\n//     body: JSON.stringify(appointment),\n//   });\n// }\n\n// // Confirm a slot\n// export async function confirmSlot(userId, doctorId, appointmentDateTime) {\n//   const appointment = {\n//     doctor_id: doctorId,\n//     appointment_date: appointmentDateTime,\n//   };\n//   const url = `${API_BASE_URL}/confirm_slot?user_id=${userId}`;\n//   return await fetchWithErrorHandling(url, {\n//     method: \"POST\",\n//     headers: { \"Content-Type\": \"application/json\" },\n//     body: JSON.stringify(appointment),\n//   });\n// }\n\n// // Cancel a reservation\n// export async function cancelSlot(userId, doctorId, appointmentDateTime) {\n//   const url = `${API_BASE_URL}/cancel_slot?doctor_id=${doctorId}&slot_time=${encodeURIComponent(appointmentDateTime)}&user_id=${userId}`;\n//   return await fetchWithErrorHandling(url, { method: \"POST\" });\n// }\n\n// api.js (TEMPORARY MOCK IMPLEMENTATIONS)\n\n// MOCK: Get available slots for a doctor on a date\nexport async function getAvailableSlots(doctorId, appDate) {\n    console.warn(\"MOCK API: getAvailableSlots called. Returning dummy slots to bypass backend crash.\");\n    \n    // Simulate a successful API call returning valid time slots (HH:MM:SS format)\n    return [\n        \"09:00:00\",\n        \"09:30:00\",\n        \"10:00:00\",\n        \"10:30:00\",\n        \"14:00:00\",\n        \"14:30:00\"\n    ];\n}\n\n// MOCK: Reserve a slot (Bypasses Redis lock logic)\nexport async function reserveSlot(userId, doctorId, appointmentDateTime) {\n    console.warn(\"MOCK API: reserveSlot called. Slot reserved for 300 seconds.\");\n    \n    // The frontend expects \"expires_in\" to calculate remaining hold time\n    return { \"message\": \"Slot reserved\", \"expires_in\": 300 };\n}\n\n// MOCK: Confirm a slot (Bypasses permanent booking logic)\nexport async function confirmSlot(userId, doctorId, appointmentDateTime) {\n    console.warn(\"MOCK API: confirmSlot called. Booking confirmed.\");\n    return { \"message\": \"Booking confirmed\" };\n}\n\n// MOCK: Cancel a reservation (Bypasses Redis key deletion)\nexport async function cancelSlot(userId, doctorId, appointmentDateTime) {\n    console.warn(\"MOCK API: cancelSlot called. Reservation cancelled.\");\n    return { \"message\": \"Reservation cancelled and slot freed\" };\n}\n\n// Note: Ensure your original `fetchWithErrorHandling` and `API_BASE_URL` are still defined in api.js, \n// as other functions (like login/vitals) may still need them.\n\n\nexport async function getUser(token) {\n  const res = await fetch(`${API_BASE_URL}/user/me`, {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  if (!res.ok) throw new Error(\"Unauthorized\");\n  return await res.json();\n}\n\nexport async function getVitals(token) {\n  const res = await fetch(`${API_BASE_URL}/get_vital`, {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch vitals\");\n  return await res.json();\n}\n\nexport async function createChatRoom(token, name, participant_ids) {\n  const res = await fetch(`${API_BASE_URL}/chats/create`, {\n    method: \"POST\",\n    headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({ name, participant_ids }),\n  });\n  if (!res.ok) throw new Error(\"Failed to create chat room\");\n  return res.json();\n}\n\nexport async function getMyChats(token) {\n  const res = await fetch(`${API_BASE_URL}/chats/my`, {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch chats\");\n  return res.json();\n}\n\nexport async function addVitals(token, patient_email, bp) {\n  const res = await fetch(`${API_BASE_URL}/add_vital`, {\n    method: \"POST\",\n    headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({ patient_email, bp }),\n  });\n  if (!res.ok) throw new Error(\"Failed to add vitals\");\n  return res.json();\n}\n\nexport async function getFamilyMembers(token) {\n  const res = await fetch(`${API_BASE_URL}/family/get_all_family_members`, {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch family members\");\n  return res.json();\n}\n\n// export async function sendInvitation(token, email, relationship_type) {\n//   const res = await fetch(`${API_BASE_URL}/family/send_invitation`, {\n//     method: \"POST\",\n//     headers: {\n//       Authorization: `Bearer ${token}`,\n//       \"Content-Type\": \"application/json\",\n//     },\n//     body: JSON.stringify({ email, relationship_type }),\n//   });\n//   if (!res.ok) throw new Error(\"Failed to send invitation\");\n//   return res.json();\n// }\n\nexport async function getChatMessages(chatId, token) {\n  const res = await fetch(`${API_BASE_URL}/chats/${chatId}/messages`, {\n    headers: { Authorization: \"Bearer \" + token },\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch chat messages\");\n  return res.json();\n}\n\nexport async function getWsToken(token) {\n  const res = await fetch(`${API_BASE_URL}/ws-token`, {\n    method: \"POST\",\n    headers: { Authorization: \"Bearer \" + token },\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch websocket token\");\n  return res.json();\n}\n\n\nexport async function getChatRooms(token) {\n  const res = await fetch(`${API_BASE_URL}/chats/my`, {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  if (!res.ok) throw new Error(\"Failed to get chat rooms\");\n  return await res.json();\n}\n\nexport async function getCurrentUser(token) {\n  const res = await fetch(`${API_BASE_URL}/user/me`, {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  if (!res.ok) throw new Error(\"Failed to fetch user info\");\n  return res.json();\n}\n\n// Logout (just clearing local/session storage)\nexport function logoutUser() {\n  sessionStorage.clear();\n  localStorage.clear();\n}\n\nexport async function getPendingInvites(token) {\n    const res = await fetch(`${API_BASE_URL}/family/family_invitation_for_current_user`, {\n        headers: { \"Authorization\": `Bearer ${token}` }\n    });\n    if (!res.ok) throw new Error(\"Failed to fetch invitations\");\n    return res.json();\n}\n\nexport async function respondInvite(token, inviteToken, action) {\n    const res = await fetch(`${API_BASE_URL}/family/respond_invitation`, {\n        method: \"PUT\",\n        headers: { \n            \"Content-Type\": \"application/json\",\n            \"Authorization\": `Bearer ${token}`\n        },\n        body: JSON.stringify({ token: inviteToken, action: action })\n    });\n    if (!res.ok) throw new Error(\"Failed to respond to invitation\");\n    return res.json();\n}\n\nconst handleResponse = async (res) => {\n    if (!res.ok) {\n        const errorBody = await res.json().catch(() => ({ detail: res.statusText }));\n        const errorMessage = errorBody.detail \n            ? (Array.isArray(errorBody.detail) ? errorBody.detail[0].msg : errorBody.detail) \n            : `HTTP error ${res.status}`;\n        throw new Error(errorMessage);\n    }\n    return res.json();\n};\n\nexport const getUserMe = async (token) => {\n    const res = await fetch(`${API_BASE_URL}/user/me`, {\n        headers: { \"Authorization\": \"Bearer \" + token }\n    });\n    return handleResponse(res);\n};\n\nexport const viewMyChats = async () => {\n    const token = sessionStorage.getItem(\"token\");\n    const res = await fetch(`${API_BASE_URL}/chats/my`, {\n        headers: { \"Authorization\": \"Bearer \" + token }\n    });\n    return handleResponse(res);\n};\n\n\nexport const addPatientVitals = async (patient_email, bp) => {\n    const token = sessionStorage.getItem(\"token\");\n    const res = await fetch(`${API_BASE_URL}/add_vital`, {\n        method: \"POST\",\n        headers: { \n            \"Authorization\": \"Bearer \" + token, \n            \"Content-Type\": \"application/json\" \n        },\n        body: JSON.stringify({ patient_email, bp })\n    });\n    return handleResponse(res);\n};\n\n// export const getAllAppointments = async () => {\n//     const token = sessionStorage.getItem(\"token\");\n//     const res = await fetch(`${API_BASE_URL}/get_all_appointments`, {\n//         headers: { \"Authorization\": \"Bearer \" + token }\n//     });\n//     return handleResponse(res);\n// };\n\nexport const respondToAppointment = async (appointment_id, action) => {\n    const token = sessionStorage.getItem(\"token\");\n    const res = await fetch(`${API_BASE_URL}/appointment_response`, {\n        method: \"PUT\",\n        headers: {\n            \"Authorization\": \"Bearer \" + token,\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ appointment_id, action })\n    });\n    return handleResponse(res);\n};\n\n// api.js (required addition)\n\n\nexport const sendFamilyInvite = async (token, invitee_email, relationship_type) => {\n    // Assuming the backend endpoint is '/family/send_invite' or similar\n    const res = await fetch(`${API_BASE_URL}/family/send_invitation`, { \n        method: \"POST\",\n        headers: {\n            \"Authorization\": \"Bearer \" + token,\n            \"Content-Type\": \"application/json\"\n        },\n        // The payload must match the InvitationRequest schema (invitee_email, relationship_type)\n        body: JSON.stringify({ \n            invitee_email: invitee_email, \n            relationship_type: relationship_type \n        })\n    });\n    return handleResponse(res); \n    // Assuming handleResponse is a helper that throws an error on !res.ok\n};\n\nexport function setupWebSocket(doctorId, handleMessage, setWsStatus) {\n  // Use 'ws:' instead of 'wss:' because API_BASE_URL is 'http:'\n  const protocol = 'ws:'; \n  const wsUrl = `${protocol}//${API_BASE_URL_without_http}/ws/doctor/${doctorId}/slots`;\n\n  const wsConnection = new WebSocket(wsUrl);\n\n  wsConnection.onopen = () => {\n    setWsStatus('Connected');\n    console.log('WebSocket connected');\n  };\n\n  wsConnection.onclose = () => {\n    setWsStatus('Disconnected');\n    console.log('WebSocket disconnected');\n  };\n\n  wsConnection.onerror = (error) => {\n    setWsStatus('Error');\n    console.error('WebSocket error:', error);\n  };\n\n  wsConnection.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n      // Data check removed: let the component handle doctor_id filtering\n      handleMessage(data); \n    } catch (error) {\n      console.error('Error processing WebSocket message:', error);\n    }\n  };\n\n  return wsConnection;\n}\n\n// export const removeFamilyMember = async (token, memberId) => {\n//   const response = await fetch(`${API_BASE_URL}/family/remove_family_member/${memberId}`, {\n//     method: 'DELETE',\n//     headers: {\n//       'Authorization': `Bearer ${token}`,\n//       'Content-Type': 'application/json'\n//     }\n//   });\n  \n//   if (!response.ok) {\n//     throw new Error('Failed to remove family member');\n//   }\n  \n//   return response.json();\n// };\n// api.js (TEMPORARY MOCK)\n\n// Assuming your remove function looks like this:\nexport async function removeFamilyMember(token, memberId) {\n    console.warn(\"MOCK API: removeFamilyMember called. Simulating successful removal.\");\n    \n    // Simulate the successful response the frontend expects for deletion.\n    return { \n        \"message\": `Family member ${memberId} successfully removed.` \n    };\n    \n    // Original code (UNMOCK THIS WHEN BACKEND IS FIXED):\n    /*\n    const res = await fetch(`${API_BASE_URL}/family/remove_family_member/${memberId}`, {\n        method: \"DELETE\",\n        headers: { \"Authorization\": \"Bearer \" + token },\n    });\n    return handleResponse(res);\n    */\n}\n\n// api.js\n\nexport async function getPatientAppointments(token) {\n    const res = await fetch(`${API_BASE_URL}/patient/appointments`, {\n        headers: { \"Authorization\": `Bearer ${token}` }\n    });\n    return handleResponse(res); // Assuming handleResponse handles 401/403 errors\n}\n\n// Update the getAllAppointments function to explicitly take the token if it needs it \n// (though it likely gets the token from sessionStorage in your existing implementation).\n// Ensure it passes the token in the headers if it relies on auth:\n// Ensure this is the only definition of getAllAppointments in your file:\n\nexport const getAllAppointments = async (token) => { // Adding token as explicit parameter\n    const tokenToUse = token || sessionStorage.getItem(\"token\"); // Fallback\n    \n    // Check if token exists before making the call\n    if (!tokenToUse) {\n        throw new Error(\"Authorization token is missing.\");\n    }\n    \n    const res = await fetch(`${API_BASE_URL}/get_all_appointments`, {\n        headers: { \"Authorization\": \"Bearer \" + tokenToUse }\n    });\n    return handleResponse(res);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}