# routers/chat.py
from fastapi import APIRouter, Depends, HTTPException, WebSocket, WebSocketDisconnect, Query
from sqlalchemy.orm import Session
from typing import List, Dict
from jose import jwt, JWTError
import models
import schemas as schemas  # or import from your main schemas.py
from database import get_db
import auth
from datetime import datetime

from chat.chat_auth import WS_SECRET_KEY, WS_ALGORITHM  # uses WS_SECRET_KEY defined there

router = APIRouter(prefix="/chats", tags=["chats"])

# In-memory connections per chat_id (for a single worker). Use Redis in production.
connections: Dict[int, List[WebSocket]] = {}


def _decode_ws_token(ws_token: str):
    try:
        payload = jwt.decode(ws_token, WS_SECRET_KEY, algorithms=[WS_ALGORITHM])
        user_id = payload.get("sub")
        if user_id is None:
            raise JWTError("missing sub")
        return int(user_id)
    except JWTError as e:
        raise HTTPException(status_code=401, detail="Invalid ws token")


@router.post("/create", response_model=schemas.ChatRoomOut)
def create_chat_room(payload: schemas.CreateChatRoomIn, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_user)):
    # Only doctors can create rooms
    if current_user.role != models.UserRoles.DOCTOR:
        raise HTTPException(status_code=403, detail="Only doctors can create chat rooms")

    # create room
    room = models.ChatRoom(name=payload.name, created_by=current_user.id)
    db.add(room)
    db.commit()
    db.refresh(room)

    # add participants (include doctor)
    participant_ids = set(payload.participant_ids)
    participant_ids.add(current_user.id)

    participants = []
    for uid in participant_ids:
        user_obj = db.query(models.User).filter(models.User.id == uid).first()
        if not user_obj:
            # skip if user doesn't exist
            continue
        p = models.ChatParticipant(chat_id=room.id, user_id=uid)
        participants.append(p)

    if participants:
        db.add_all(participants)
        db.commit()

    return room


@router.get("/my", response_model=List[schemas.ChatRoomOut])
def get_my_rooms(db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_user)):
    rooms = (
        db.query(models.ChatRoom)
        .join(models.ChatParticipant, models.ChatParticipant.chat_id == models.ChatRoom.id)
        .filter(models.ChatParticipant.user_id == current_user.id)
        .all()
    )
    return rooms


@router.get("/{chat_id}/messages", response_model=List[schemas.ChatMessageOut])
def get_chat_messages(chat_id: int, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_user)):
    # ensure membership
    participant = db.query(models.ChatParticipant).filter(
        models.ChatParticipant.chat_id == chat_id,
        models.ChatParticipant.user_id == current_user.id
    ).first()
    if not participant:
        raise HTTPException(status_code=403, detail="Not a member of this chat")

    messages = db.query(models.ChatMessage).filter(models.ChatMessage.chat_id == chat_id).order_by(models.ChatMessage.timestamp).all()

    out = []
    for m in messages:
        out.append(schemas.ChatMessageOut(
            id=m.id,
            chat_id=m.chat_id,
            sender_id=m.sender_id,
            content=m.content,
            timestamp=m.timestamp.isoformat()
        ))
    return out


@router.websocket("/ws/{chat_id}")
async def websocket_chat(websocket: WebSocket, chat_id: int, ws_token: str = Query(...), db: Session = Depends(get_db)):
    """
    Connect with: ws://host/chats/ws/{chat_id}?ws_token=<short_token>
    The short-lived token is generated by POST /ws-token
    """
    # validate ws_token
    try:
        user_id = _decode_ws_token(ws_token)
    except HTTPException:
        await websocket.close(code=1008)
        return

    # check membership
    participant = db.query(models.ChatParticipant).filter(
        models.ChatParticipant.chat_id == chat_id,
        models.ChatParticipant.user_id == user_id
    ).first()
    if not participant:
        await websocket.close(code=1008)
        return

    # accept and register
    await websocket.accept()
    chat_id_int = int(chat_id)
    connections.setdefault(chat_id_int, []).append(websocket)

    try:
        while True:
            data = await websocket.receive_json()
            content = data.get("content")
            if not content:
                continue

            # save message
            msg = models.ChatMessage(chat_id=chat_id_int, sender_id=user_id, content=content)
            db.add(msg)
            db.commit()
            db.refresh(msg)

            payload = {
                "id": msg.id,
                "chat_id": msg.chat_id,
                "sender_id": msg.sender_id,
                "content": msg.content,
                "timestamp": msg.timestamp.isoformat()
            }

            # broadcast to all connections in this chat
            conns = list(connections.get(chat_id_int, []))
            for conn in conns:
                try:
                    await conn.send_json(payload)
                except:
                    pass

    except WebSocketDisconnect:
        if websocket in connections.get(chat_id_int, []):
            connections[chat_id_int].remove(websocket)
    except Exception:
        # ensure cleanup
        if websocket in connections.get(chat_id_int, []):
            connections[chat_id_int].remove(websocket)
        try:
            await websocket.close()
        except:
            pass
